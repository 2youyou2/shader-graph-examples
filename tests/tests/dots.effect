// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
CCEffect %{
  techniques:
  - name: opaque
    passes:
    - vert: unlit-vs:vert
      frag: unlit-fs:frag
      properties: &props
        

  - name: transparent
    passes:
    - vert: unlit-vs:vert
      frag: unlit-fs:frag
      depthStencilState: &d1
        depthTest: true
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendDstAlpha: one_minus_src_alpha
      properties: *props
  - name: add
    passes:
    - vert: unlit-vs:vert
      frag: unlit-fs:frag
      rasterizerState: &r1 { cullMode: none }
      depthStencilState: *d1
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one
          blendSrcAlpha: src_alpha
          blendDstAlpha: one
      properties: *props
  - name: alpha-blend
    passes:
    - vert: unlit-vs:vert
      frag: unlit-fs:frag
      rasterizerState: *r1
      depthStencilState: *d1
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendSrcAlpha: src_alpha
          blendDstAlpha: one_minus_src_alpha
      properties: *props
}%



CCProgram shader_graph_common %{

float randomRange (vec2 seed, float min, float max) {
    float randomno = frac(sin(dot(seed, vec2(12.9898, 78.233)))*43758.5453);
    return lerp(min, max, randomno);
}

float ellipse (vec2 uv, float width, float height) {
    #if USE_standard_derivatives
        float d = length((uv * 2. - 1.) / vec2(width, height));
        return saturate((1. - d) / fwidth(d));
    #else
        return 1.;
    #endif
}

#define saturate(Value) clamp(Value, 0., 1.)

}%


CCProgram properties %{
  uniform Properties {
    

  };

  
}%

CCProgram unlit-vs %{
  precision highp float;
  #include <input>
  #include <cc-global>
  #include <cc-local-batch>
  #include <properties>

  
  #include <shader_graph_common>
        

  vec4 vert () {
    vec4 position;
    CCVertInput(position);

    mat4 matWorld;
    CCGetWorldMatrix(matWorld);

    


    position = position;

    return cc_matProj * (cc_matView * matWorld) * position;
  }
}%

CCProgram unlit-fs %{
  #if USE_standard_derivatives
    #extension GL_OES_standard_derivatives : enable
  #endif
  
  precision mediump float;
  #include <output>
  #include <properties>
  
  
  #include <shader_graph_common>
        

  vec4 frag () {
    vec4 o = vec4(1.);

    

    float var_6 = 0.8999999761581421;
    vec2 var_7 = vec2(8., 8.);
    float var_8 = 0.5;
    float var_9 = 1;
    
    vec2 var_16 = vec2(0., 0.) * var_7 + vec2(0., 0.);
    float var_35 = vec4(var_16, 0., 0.).r;
    float var_36 = vec4(var_16, 0., 0.).g;
    float var_37 = vec4(var_16, 0., 0.).b;
    float var_38 = vec4(var_16, 0., 0.).a;
    
    float var_59 = vec4(var_16, 0., 0.).r;
    float var_60 = vec4(var_16, 0., 0.).g;
    float var_61 = vec4(var_16, 0., 0.).b;
    float var_62 = vec4(var_16, 0., 0.).a;
    
    vec4 var_33 = mod(vec4(var_36, 0., 0., 0.), vec4(2., 2., 1., 1.));
    vec4 var_57 = mod(vec4(var_59, 0., 0., 0.), vec4(2., 2., 1., 1.));
    vec4 var_24 = step(vec4(1., 1., 1., 1.), var_33);
    vec4 var_53 = step(vec4(1., 1., 1., 1.), var_57);
    float var_30 = var_8 * var_24.x;
    float var_19 = var_9 * var_53.x;
    vec4 var_27 = vec4(var_35, 0., 0., 0.) + vec4(var_30, 0., 0., 0.);
    vec4 var_47 = vec4(var_60, 0., 0., 0.) + vec4(var_19, 0., 0., 0.);
    vec2 var_50 = vec2(var_27.x, var_47.x);
    vec4 var_21 = frac(vec4(var_50, 0., 0.));
    float var_44 = Size;
    float var_43 = ellipse(var_21.xy, var_44, var_6);

    o.rgb *= vec3(var_43, 0.7353569269180298, 0.7353569269180298);
    o.a *= 1.;

    return CCFragOutput(o);
  }
}%
