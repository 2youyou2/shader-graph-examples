// Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.
CCEffect %{
  techniques:
  - name: opaque
    passes:
    - vert: unlit-vs:vert
      frag: unlit-fs:frag
      properties: &props
        {{properties_mtl}}
  - name: transparent
    passes:
    - vert: unlit-vs:vert
      frag: unlit-fs:frag
      depthStencilState: &d1
        depthTest: true
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendDstAlpha: one_minus_src_alpha
      properties: *props
  - name: add
    passes:
    - vert: unlit-vs:vert
      frag: unlit-fs:frag
      rasterizerState: &r1 { cullMode: none }
      depthStencilState: *d1
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one
          blendSrcAlpha: src_alpha
          blendDstAlpha: one
      properties: *props
  - name: alpha-blend
    passes:
    - vert: unlit-vs:vert
      frag: unlit-fs:frag
      rasterizerState: *r1
      depthStencilState: *d1
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendSrcAlpha: src_alpha
          blendDstAlpha: one_minus_src_alpha
      properties: *props
}%



CCProgram shader_graph_common %{

void randomRange (vec2 seed, float min, float max, out float out) {
    float randomno = frac(sin(dot(seed, vec2(12.9898, 78.233)))*43758.5453);
    out = lerp(Min, Max, randomno);
}

void ellipse (vec2 uv, float width, float height, out float out) {
    float d = length((uv * 2 - 1) / vec2(width, height));
    out = saturate((1 - d) / fwidth(d));
}

#define saturate(Value) clamp(Value, 0., 1.)

}%


CCProgram properties %{
  uniform Properties {
    {{properties}}
  };

  {{properties_sampler}}
}%

CCProgram unlit-vs %{
  precision highp float;
  #include <input>
  #include <cc-global>
  #include <cc-local-batch>
  #include <properties>

  
  #include<shader_graph_common>
        

  vec4 vert () {
    vec4 position;
    CCVertInput(position);

    mat4 matWorld;
    CCGetWorldMatrix(matWorld);

    


    position = ;

    return cc_matProj * (cc_matView * matWorld) * position;
  }
}%

CCProgram unlit-fs %{
  precision mediump float;
  #include <output>
  #include <properties>
  
  
  #include<shader_graph_common>
        

  vec4 frag () {
    vec4 o = vec4(1.);

    

    
    vec2 var_16 = vec2(0, 0) * var_12 + vec2(0, 0);
    float var_35 = var_16.r;
    float var_36 = var_16.g;
    
    float var_59 = var_16.r;
    float var_60 = var_16.g;
    
    var_33 = mod(var_36, vec4(2, 2, 1, 1));
    var_57 = mod(var_59, vec4(2, 2, 1, 1));
    
    var_24 = step(vec4(1, 1, 1, 1), var_33);
    
    var_53 = step(vec4(1, 1, 1, 1), var_57);
    var_30 = var_39 * var_24;
    var_19 = var_54 * var_53;
    var_27 = var_35 + var_30;
    var_47 = var_60 + var_19;
    vec2 var_50 = var_27;
    var_21 = frac(var_50);
    
    
    ellipse(var_21, var_44, var_44, var_43);

    o.rgb *= var_10;
    o.a *= 1.;

    return CCFragOutput(o);
  }
}%
