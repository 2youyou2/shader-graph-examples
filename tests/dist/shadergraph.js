"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShaderGraph = void 0;
const base_1 = require("./base");
const utils_1 = require("./utils");
const nodes_1 = require("./nodes");
const MasterNode_1 = __importDefault(require("./nodes/master/MasterNode"));
const SubGraphNode_1 = __importDefault(require("./nodes/subgraph/SubGraphNode"));
const fs_1 = __importDefault(require("fs"));
const PropertyNode_1 = __importDefault(require("./nodes/input/PropertyNode"));
class ShaderGraph {
    static searchNodes(graphPath) {
        let contentStr = fs_1.default.readFileSync(graphPath, 'utf-8');
        let content = utils_1.getJsonObject(contentStr);
        if (!content)
            return;
        let properties = content.m_SerializedProperties.map(d => new base_1.ShaderPropery(d));
        let nodeMap = new Map;
        let propertyNodeMap = new Map;
        let nodes = content.m_SerializableNodes.map(d => {
            let node = nodes_1.createNode(d);
            if (node instanceof PropertyNode_1.default) {
                node.searchProperties(properties);
                let propertyNode = propertyNodeMap.get(node.property);
                if (propertyNode) {
                    nodeMap.set(node.uuid, propertyNode);
                    return propertyNode;
                }
                propertyNodeMap.set(node.property, node);
            }
            nodeMap.set(node.uuid, node);
            return node;
        });
        let edges = content.m_SerializableEdges.map(d => {
            return new base_1.ShaderEdge(d);
        });
        for (let i = 0; i < edges.length; i++) {
            let edge = edges[i];
            let inputSlot = edge.input;
            let outputSlot = edge.output;
            let inputNode = nodeMap.get(inputSlot.nodeUuid);
            let outputNode = nodeMap.get(outputSlot.nodeUuid);
            if (outputNode instanceof SubGraphNode_1.default) {
                outputNode = outputNode.excahngeSubGraphOutNode(outputSlot);
            }
            if (!inputNode) {
                console.warn(`Can not find input [${inputSlot.nodeUuid}] for edge.`);
                continue;
            }
            if (!outputNode) {
                console.warn(`Can not find input [${outputSlot.nodeUuid}] for edge.`);
                continue;
            }
            inputNode.addDependency(outputNode);
            outputNode.setPriority(inputNode.priority + 1);
            let inputNodeSlot = inputNode.slotsMap.get(inputSlot.id);
            let outputNodeSlot = outputNode.slotsMap.get(outputSlot.id);
            if (inputNodeSlot && outputNodeSlot) {
                inputNodeSlot.connectSlots.push(outputNodeSlot);
                outputNodeSlot.connectSlots.push(inputNodeSlot);
            }
        }
        nodes.sort((a, b) => b.priority - a.priority);
        nodes.forEach(node => {
            if (node instanceof SubGraphNode_1.default) {
                node.exchangeSubGraphInputNodes();
            }
            node.calcConcretePrecision();
        });
        this.allNodes.push(nodes);
        return {
            properties,
            nodeMap,
            nodes,
            edges
        };
    }
    static decode(path) {
        base_1.resetGlobalShaderSlotID();
        this.allNodes.length = 0;
        let res = this.searchNodes(path);
        if (!res) {
            return;
        }
        let { properties, nodeMap, nodes, edges } = res;
        let masterNode = nodes.find(n => n instanceof MasterNode_1.default);
        if (!masterNode) {
            console.error('Can not find master node.');
            return;
        }
        masterNode.properties = properties;
        let code = masterNode.generateCode();
        return code;
    }
}
exports.ShaderGraph = ShaderGraph;
ShaderGraph.subgraphPath = '';
ShaderGraph.allNodes = [];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2hhZGVyZ3JhcGguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvc2hhZGVyZ3JhcGgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsaUNBQXdGO0FBQ3hGLG1DQUF3QztBQUN4QyxtQ0FBcUM7QUFDckMsMkVBQW1EO0FBQ25ELGlGQUF5RDtBQUV6RCw0Q0FBbUI7QUFDbkIsOEVBQXNEO0FBRXRELE1BQWEsV0FBVztJQUtwQixNQUFNLENBQUMsV0FBVyxDQUFFLFNBQWlCO1FBQ2pDLElBQUksVUFBVSxHQUFHLFlBQUUsQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ3JELElBQUksT0FBTyxHQUFHLHFCQUFhLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDeEMsSUFBSSxDQUFDLE9BQU87WUFBRSxPQUFPO1FBRXJCLElBQUksVUFBVSxHQUFvQixPQUFPLENBQUMsc0JBQXNCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxvQkFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDaEcsSUFBSSxPQUFPLEdBQTRCLElBQUksR0FBRyxDQUFDO1FBRS9DLElBQUksZUFBZSxHQUFxQyxJQUFJLEdBQUcsQ0FBQztRQUVoRSxJQUFJLEtBQUssR0FBaUIsT0FBTyxDQUFDLG1CQUFtQixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUMxRCxJQUFJLElBQUksR0FBRyxrQkFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRXpCLElBQUksSUFBSSxZQUFZLHNCQUFZLEVBQUU7Z0JBQzlCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsQ0FBQztnQkFFbEMsSUFBSSxZQUFZLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBQ3RELElBQUksWUFBWSxFQUFFO29CQUNkLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFD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QUMsTUFBTSxDQUFFLElBQVk7UUFFdkIsOEJBQXVCLEVBQUUsQ0FBQztRQUUxQixJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7UUFFekIsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNqQyxJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ04sT0FBTztTQUNWO1FBRUQsSUFBSSxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxHQUFHLEdBQUcsQ0FBQztRQUVoRCxJQUFJLFVBQVUsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxZQUFZLG9CQUFVLENBQUMsQ0FBQztRQUMxRCxJQUFJLENBQUMsVUFBVSxFQUFFO1lBQ2IsT0FBTyxDQUFDLEtBQUssQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO1lBQzNDLE9BQU87U0FDVjtRQUVBLFVBQXlCLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztRQUVuRCxJQUFJLElBQUksR0FBRyxVQUFVLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDckMsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQzs7QUFuSEwsa0NBb0hDO0FBbkhVLHdCQUFZLEdBQUcsRUFBRSxDQUFBO0FBRWpCLG9CQUFRLEdBQW1CLEVBQUUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNoYWRlclByb3BlcnksIFNoYWRlck5vZGUsIFNoYWRlckVkZ2UsIHJlc2V0R2xvYmFsU2hhZGVyU2xvdElEIH0gZnJvbSBcIi4vYmFzZVwiO1xyXG5pbXBvcnQgeyBnZXRKc29uT2JqZWN0IH0gZnJvbSBcIi4vdXRpbHNcIjtcclxuaW1wb3J0IHsgY3JlYXRlTm9kZSB9IGZyb20gXCIuL25vZGVzXCI7XHJcbmltcG9ydCBNYXN0ZXJOb2RlIGZyb20gXCIuL25vZGVzL21hc3Rlci9NYXN0ZXJOb2RlXCI7XHJcbmltcG9ydCBTdWJHcmFwaE5vZGUgZnJvbSBcIi4vbm9kZXMvc3ViZ3JhcGgvU3ViR3JhcGhOb2RlXCI7XHJcblxyXG5pbXBvcnQgZnMgZnJvbSAnZnMnXHJcbmltcG9ydCBQcm9wZXJ0eU5vZGUgZnJvbSBcIi4vbm9kZXMvaW5wdXQvUHJvcGVydHlOb2RlXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgU2hhZGVyR3JhcGgge1xyXG4gICAgc3RhdGljIHN1YmdyYXBoUGF0aCA9ICcnXHJcblxyXG4gICAgc3RhdGljIGFsbE5vZGVzOiBTaGFkZXJOb2RlW11bXSA9IFtdO1xyXG5cclxuICAgIHN0YXRpYyBzZWFyY2hOb2RlcyAoZ3JhcGhQYXRoOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgY29udGVudFN0ciA9IGZzLnJlYWRGaWxlU3luYyhncmFwaFBhdGgsICd1dGYtOCcpO1xyXG4gICAgICAgIGxldCBjb250ZW50ID0gZ2V0SnNvbk9iamVjdChjb250ZW50U3RyKTtcclxuICAgICAgICBpZiAoIWNvbnRlbnQpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IHByb3BlcnRpZXM6IFNoYWRlclByb3BlcnlbXSA9IGNvbnRlbnQubV9TZXJpYWxpemVkUHJvcGVydGllcy5tYXAoZCA9PiBuZXcgU2hhZGVyUHJvcGVyeShkKSk7XHJcbiAgICAgICAgbGV0IG5vZGVNYXA6IE1hcDxzdHJpbmcsIFNoYWRlck5vZGU+ID0gbmV3IE1hcDtcclxuXHJcbiAgICAgICAgbGV0IHByb3BlcnR5Tm9kZU1hcDogTWFwPFNoYWRlclByb3BlcnksIFByb3BlcnR5Tm9kZT4gPSBuZXcgTWFwO1xyXG5cclxuICAgICAgICBsZXQgbm9kZXM6IFNoYWRlck5vZGVbXSA9IGNvbnRlbnQubV9TZXJpYWxpemFibGVOb2Rlcy5tYXAoZCA9PiB7XHJcbiAgICAgICAgICAgIGxldCBub2RlID0gY3JlYXRlTm9kZShkKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgUHJvcGVydHlOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLnNlYXJjaFByb3BlcnRpZXMocHJvcGVydGllcyk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGxldCBwcm9wZXJ0eU5vZGUgPSBwcm9wZXJ0eU5vZGVNYXAuZ2V0KG5vZGUucHJvcGVydHkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVNYXAuc2V0KG5vZGUudXVpZCwgcHJvcGVydHlOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHlOb2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHByb3BlcnR5Tm9kZU1hcC5zZXQobm9kZS5wcm9wZXJ0eSwgbm9kZSk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBub2RlTWFwLnNldChub2RlLnV1aWQsIG5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGV0IGVkZ2VzOiBTaGFkZXJFZGdlW10gPSBjb250ZW50Lm1fU2VyaWFsaXphYmxlRWRnZXMubWFwKGQgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNoYWRlckVkZ2UoZClcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBlZGdlID0gZWRnZXNbaV07XHJcbiAgICAgICAgICAgIGxldCBpbnB1dFNsb3QgPSBlZGdlLmlucHV0O1xyXG4gICAgICAgICAgICBsZXQgb3V0cHV0U2xvdCA9IGVkZ2Uub3V0cHV0O1xyXG5cclxuICAgICAgICAgICAgbGV0IGlucHV0Tm9kZSA9IG5vZGVNYXAuZ2V0KGlucHV0U2xvdC5ub2RlVXVpZCk7XHJcbiAgICAgICAgICAgIGxldCBvdXRwdXROb2RlID0gbm9kZU1hcC5nZXQob3V0cHV0U2xvdC5ub2RlVXVpZCk7XHJcblxyXG4gICAgICAgICAgICBpZiAob3V0cHV0Tm9kZSBpbnN0YW5jZW9mIFN1YkdyYXBoTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0Tm9kZSA9IG91dHB1dE5vZGUuZXhjYWhuZ2VTdWJHcmFwaE91dE5vZGUob3V0cHV0U2xvdCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghaW5wdXROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYENhbiBub3QgZmluZCBpbnB1dCBbJHtpbnB1dFNsb3Qubm9kZVV1aWR9XSBmb3IgZWRnZS5gKVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFvdXRwdXROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYENhbiBub3QgZmluZCBpbnB1dCBbJHtvdXRwdXRTbG90Lm5vZGVVdWlkfV0gZm9yIGVkZ2UuYClcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpbnB1dE5vZGUuYWRkRGVwZW5kZW5jeShvdXRwdXROb2RlKTtcclxuICAgICAgICAgICAgb3V0cHV0Tm9kZS5zZXRQcmlvcml0eShpbnB1dE5vZGUucHJpb3JpdHkgKyAxKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBpbnB1dE5vZGVTbG90ID0gaW5wdXROb2RlLnNsb3RzTWFwLmdldChpbnB1dFNsb3QuaWQpO1xyXG4gICAgICAgICAgICBsZXQgb3V0cHV0Tm9kZVNsb3QgPSBvdXRwdXROb2RlLnNsb3RzTWFwLmdldChvdXRwdXRTbG90LmlkKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpbnB1dE5vZGVTbG90ICYmIG91dHB1dE5vZGVTbG90KSB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dE5vZGVTbG90LmNvbm5lY3RTbG90cy5wdXNoKG91dHB1dE5vZGVTbG90KTtcclxuICAgICAgICAgICAgICAgIG91dHB1dE5vZGVTbG90LmNvbm5lY3RTbG90cy5wdXNoKGlucHV0Tm9kZVNsb3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBub2Rlcy5zb3J0KChhLCBiKSA9PiBiLnByaW9yaXR5IC0gYS5wcmlvcml0eSk7XHJcblxyXG4gICAgICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgU3ViR3JhcGhOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLmV4Y2hhbmdlU3ViR3JhcGhJbnB1dE5vZGVzKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG5vZGUuY2FsY0NvbmNyZXRlUHJlY2lzaW9uKCk7XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgdGhpcy5hbGxOb2Rlcy5wdXNoKG5vZGVzKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJvcGVydGllcyxcclxuICAgICAgICAgICAgbm9kZU1hcCxcclxuICAgICAgICAgICAgbm9kZXMsXHJcbiAgICAgICAgICAgIGVkZ2VzXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBkZWNvZGUgKHBhdGg6IHN0cmluZykge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJlc2V0R2xvYmFsU2hhZGVyU2xvdElEKCk7XHJcblxyXG4gICAgICAgIHRoaXMuYWxsTm9kZXMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgbGV0IHJlcyA9IHRoaXMuc2VhcmNoTm9kZXMocGF0aCk7XHJcbiAgICAgICAgaWYgKCFyZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHsgcHJvcGVydGllcywgbm9kZU1hcCwgbm9kZXMsIGVkZ2VzIH0gPSByZXM7XHJcblxyXG4gICAgICAgIGxldCBtYXN0ZXJOb2RlID0gbm9kZXMuZmluZChuID0+IG4gaW5zdGFuY2VvZiBNYXN0ZXJOb2RlKTtcclxuICAgICAgICBpZiAoIW1hc3Rlck5vZGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ2FuIG5vdCBmaW5kIG1hc3RlciBub2RlLicpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAobWFzdGVyTm9kZSBhcyBNYXN0ZXJOb2RlKS5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcclxuXHJcbiAgICAgICAgbGV0IGNvZGUgPSBtYXN0ZXJOb2RlLmdlbmVyYXRlQ29kZSgpO1xyXG4gICAgICAgIHJldHVybiBjb2RlO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==